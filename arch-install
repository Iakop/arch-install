#!/bin/bash

###########################################################################
# Check the environment
###########################################################################

envinfo="env.info"
envinfopath="/tmp/$envinfo"

# Check for virtualization:
hypervisor=$(dmesg | grep "Hypervisor detected") 2>&1
retval=$?
if [ $retval -eq 0 ]; then
	virtualization="$(echo "$hypervisor" | awk -F ': ' '{print $2}')"
	virtualization=${virtualization,,}
	echo "VIRTUALIZATION IS $virtualization"
else
	virtualization="none"
fi

# Check for virtualization:
vmcompany=$(dmesg | grep "DMI") 2>&1
retval=$?
if [ $retval -eq 0 ]; then

	echo "$vmcompany" | grep -i "virtualbox" >/dev/null 2>&1
	virtualboxcheck=$?
	echo "$vmcompany" | grep -i "vmware" >/dev/null 2>&1
	vmwarecheck=$?

	if [ $virtualboxcheck -eq 0 ]; then
		vmtype="virtualbox"
		echo "VMTYPE IS $vmtype"
	elif [ $vmwarecheck -eq 0 ]; then
		vmtype="vmware"
		echo "VMTYPE IS $vmtype"
	else
		vmtype="none"
	fi
else
	echo "Error in detecting VMTYPE!"
fi

# Check for environment variables:
env | grep DEVMODE >/dev/null 2>&1
retval=$?
if [ $retval -eq 0 ]; then
	devmode="$(env | grep DEVMODE | awk -F '=' '{print $2}')"
	echo "DEV MODE IS $devmode"
else
	devmode="off"
fi

env | grep TESTINGMODE >/dev/null 2>&1
retval=$?
if [ $retval -eq 0 ]; then
	testingmode="$(env | grep DEVMODE | awk -F '=' '{print $2}')"
	echo "TESTING MODE IS $testingmode"
else
	testingmode="off"
fi

echo "" > $envinfopath
echo "VMTYPE=$vmtype" >> envinfopath
echo "VIRTUALIZATION=$virtualization" >> envinfopath
echo "DEVMODE=$devmode" >> envinfopath
echo "TESTINGMODE=$testingmode" >> envinfopath

###########################################################################
# Connect to the internet
###########################################################################

# Using nc, the connection to the internet is checked
echo "Checking for internet access..."
dns=8.8.8.8
nc -z -w 30 $dns 53 > /dev/null 2>&1
connectioncheck=$?

if [ $connectioncheck -eq 0 ] 
then
	echo "Connected to the internet!"
else
	echo "There is no connection, please remedy and run script again."
	exit 1
fi
echo

###########################################################################
# Set the system clock
###########################################################################

# Prompt, if user wants to set a timezone:
echo "Would you like to set the clock to a custom timezone? [Y/n]: "
# Check for input:
read response

if [ $testingmode == "on" ]; then
response="y"
fi

if [ "${response,,}" == "y" ] || [ "${response,,}" == "" ]; then
	timezoneselect="custom"

elif [ "${response,,}" == "n" ]; then
	timezoneselect="default"
else
	echo "I did not understand that, please try again!"
fi

# Only when properly running:
tzinfo="tz.info"
tzinfopath="/tmp/$tzinfo"
tzexit=1

while [ $tzexit -eq 1 ] && [ $timezoneselect == "custom" ]; do

	# Prompt for user specified timezone info:
	echo "Please input the timezone (format: Region/City): "
	read tzresponse

	if [ $testingmode == "on" ]; then
	tzresponse="Europe/Copenhagen"
	fi

	echo "Checking for timezone info..."
	ls /usr/share/zoneinfo/$tzresponse >/dev/null 2>&1
	timezonecheck=$?

	# If the timezone exists, then link it:
	if [ $timezonecheck -eq 0 ] && [ "$tzresponse" != "" ]; then
		echo "Timezone found!"
		tzexit=0

	# Else ask if the user wants to try again:
	else
		echo "Timezone info not found, would you like to try again? [Y/n]: "
		# Check for input:
		validresponse=1
		while [ $validresponse -eq 1 ]; do
			read response
			if [ "${response,,}" == "y" ] || [ "${response,,}" == "" ]; then
				validresponse=0
				timezoneselect="custom"
				
			elif [ "${response,,}" == "n" ]; then
				validresponse=0
				timezoneselect="default"
				tzexit=0
			else
				echo "I did not understand that, please try again!"
			fi
		done
	fi
done

# Apply changes to timezone as requested:
if [ $timezoneselect == "custom" ]; then
	echo "Timezone will be set to $tzresponse!"
elif [ $timezoneselect == "default" ]; then
	echo "Timezone will be set to default (UTC)!"
	tzresponse="UTC"
fi
echo "/usr/share/zoneinfo/$tzresponse" > $tzinfopath

# Set the system clock
echo "Synchronizing the system clock..."
timedatectl set-ntp true
timedatectl set-timezone $tzresponse
timedatectl status
echo "Done setting time!"
echo

###########################################################################
# Check the boot type:
###########################################################################

# First list the directory with efivars, and check whether they exist:
# Redirect stdout and stderr to /dev/null
echo "Checking boot type..."
ls /sys/firmware/efi/efivars > /dev/null 2>&1
efivarscheck=$?

bootinfo="boot.info"
bootinfopath="/tmp/$bootinfo"

if [ $efivarscheck -eq 2 ] 
then
	echo "The system uses BIOS boot!"
	echo "bios" > $bootinfopath
elif [ $efivarscheck -eq 0 ]
then
	echo "The system uses UEFI boot!"
	echo "uefi" > $bootinfopath
fi
echo

###########################################################################
# Detect hardware: CPU
###########################################################################

# Detect the manufacturer of the CPU, to install microcode.
echo "Detecting CPU manufacturer..."

cpunames="$(cat /proc/cpuinfo | grep "model name" | awk -F ': ' '{print "\t" $2}')"
echo "CPU(s) found:"
echo -e "$cpunames"

# Declare an array for needed microcode:
declare -a vendorucode

echo "$cpuname" | grep -e Intel >/dev/null 2>&1
retval=$?
if [ $retval -eq 0 ]; then
	vendorucode+=("intel-ucode")
fi

echo "$cpuname" | grep -e AMD >/dev/null 2>&1
retval=$?
if [ $retval -eq 0 ]; then
	vendorucode+=("amd-ucode")
fi

# Add microcode packages to list:
ucodelist="ucode.list"
ucodelistpath="/tmp/$ucodelist"

# Empty file, if used before and interrupted:
echo "" > $ucodelistpath

if [ "${vendorucode[0]}" != "" ]; then
	echo "The following microcode update packages will be installed:"
	for ucode in "${!vendorucode[@]}"
	do
		echo -e "${vendorucode[$ucode]}" >> $ucodelistpath
	done
	# output the results nicely:
	sed 's/^/\t/' $ucodelistpath
else
	echo "No microcode updates to install!"
fi
echo

###########################################################################
# Detect hardware: RAM
###########################################################################

echo "Detecting RAM available..."
free -h --giga
ramavail=$(free -h --giga | grep Mem | awk '{gsub("G","")} {printf "%.1f", $2}')
ramavailint=$(echo "$ramavail" | awk '{printf "%d", $1}') 
if [ $ramavailint -ne 0 ]; then
	echo "$ramavail Gigabyte RAM available!"
else
	ramavail=$(free --mega | grep Mem | awk '{printf "%.1f", $2}')
	echo "$ramavail Megabyte RAM available!"
fi
echo

###########################################################################
# Detect hardware: Storage
###########################################################################

echo "Checking disks available..."
echo "List of block devices:"
disksavail=($(lsblk | grep disk | awk '{print $1}'))
sizesavail=($(lsblk | grep disk | awk '{print $4}'))

lsblk; echo

echo "Please pick a disk to install on:"
for i in "${!disksavail[@]}"
do
	echo -e "\t$i) /dev/${disksavail[$i]} ${sizesavail[$i]}"
done
echo -e "\tq) Abort install"

# Check for input:
validresponse=1
while [ $validresponse -eq 1 ]; do
	read response

	if [ $testingmode == "on" ]; then
		response="0"
	fi
	
	# Check if response is a number, and the number index exists within the options:
	if [ $response -eq $response ] 2> /dev/null && [ "${disksavail[${response}]+y}" == "y" ]; then
		validresponse=0
		choicenumber=$response
		
	elif [ "${response,,}" == "q" ]; then
		echo "Aborting install!"
		exit 1
	else
		echo "I did not understand that, please try again!"
	fi
done
echo "You picked: $choicenumber) /dev/${disksavail[$choicenumber]} with ${sizesavail[$choicenumber]} space!"

diskinfo="disk.info"
diskinfopath="/tmp/$diskinfo"

# Write the disk choice to diskinfo:
echo /dev/${disksavail[$choicenumber]} > $diskinfopath
echo

###########################################################################
# Detect hardware: Graphics
###########################################################################

echo "Checking for graphics hardware..."
# To get the graphics, two categories are searched using lspci:
if [ $testingmode == "on" ]; then 
	vgacontrollers=$(cat test/testpci | grep VGA | awk -F '"' '{print "\t" $6 " by " $4}')
	dddcontrollers=$(cat test/testpci | grep 3D | awk -F '"' '{print "\t" $6 " by " $4}')
else
	# VGA compatible cards, usually the main:
	vgacontrollers=$(lspci -mm | grep VGA | awk -F '"' '{print "\t" $6 " by " $4}')
	# 3D controllers, usually secondary in a prime setup.
	dddcontrollers=$(lspci -mm | grep 3D | awk -F '"' '{print "\t" $6 " by " $4}')
fi

# Then a check is performed to see if there are occurances in either category:
if [ "$vgacontrollers" != "" ]; then
	echo "Found VGA controllers:"
	echo -e "$vgacontrollers"
fi
if [ "$dddcontrollers" != "" ]; then
	echo "Found 3D controllers:"
	echo -e "$dddcontrollers"
fi

# Declare an array for vendors of 3d accelerated graphics:
declare -a graphicsdrivers

# Check for different corporations, to provide the drivers:
echo -e "$vgacontrollers" | grep -e NVIDIA | grep -i "GeForce.*[1-9][0-9][0-9][0-9][^0-9]" > /dev/null 2>&1
geforce1000plus=$?

echo -e "$vgacontrollers" | grep -e NVIDIA | grep -i "GeForce.*[6-9][0-9][0-9][^0-9]" > /dev/null 2>&1
geforce600to900=$?

echo -e "$vgacontrollers" | grep -e NVIDIA | grep -i "GeForce.*[4-5][0-9][0-9][^0-9]" > /dev/null 2>&1
geforce400to500=$?

echo -e "$vgacontrollers" | grep -e NVIDIA | grep -i "GeForce.*[1-3][0-9][0-9][^0-9]" > /dev/null 2>&1
geforce100to300=$?

echo -e "$vgacontrollers" | grep -e NVIDIA > /dev/null 2>&1
nvidiacheck=$?

# The newer Nvidia drivers will blacklist nouveau, so only one can prevail:
if [ $geforce1000plus -eq 0 ] || [ $geforce600to900 -eq 0 ]; then
	graphicsdrivers+=("nvidia" "nvidia-utils" "lib32-nvidia-utils")
elif [ $geforce400to500 -eq 0 ]; then
	graphicsdrivers+=("nvidia-390xx" "nvidia-390xx-utils" "lib32-nvidia-390xx-utils")
elif [ $geforce100to300 -eq 0 ]; then
	graphicsdrivers+=("xf86-video-nouveau")
fi

# If every other nvidia-check fails, install nouveau as fallback:
if [ $nvidiacheck -eq 0 ] && [ $geforce100to300 -ne 0 ] && [ $geforce1000plus -ne 0 ] && [ $geforce600to900 -ne 0 ] && [ $geforce400to500 -ne 0 ]; then
	oldnvidia=0
	graphicsdrivers+=("xf86-video-nouveau")
fi

echo -e "$vgacontrollers" | grep -e Intel > /dev/null 2>&1
intelcheck=$?
if [ $intelcheck -eq 0 ]; then
	graphicsdrivers+=("xf86-video-intel" "vulkan-intel")
fi

echo -e "$vgacontrollers" | grep -e AMD > /dev/null 2>&1
amdcheck=$?
if [ $amdcheck -eq 0 ]; then
	graphicsdrivers+=("xf86-video-amdgpu" "vulkan-radeon")
fi

echo -e "$vgacontrollers" | grep -e ATI > /dev/null 2>&1
aticheck=$?
if [ $aticheck -eq 0 ]; then
	graphicsdrivers+=("xf86-video-ati")
fi

echo -e "$vgacontrollers" | grep -e VMware > /dev/null 2>&1
vmwaresvgacheck=$?
if [ $vmwaresvgacheck -eq 0 ]; then
	graphicsdrivers+=("xf86-video-vmware")
fi

# Check for common drivers to be installed:
if [ $intelcheck -eq 0 ] || [ $amdcheck -eq 0 ] || [ $aticheck -eq 0 ] || [ $oldnvidia -eq 0 ] || [ $vmwaresvgacheck -eq 0 ]; then
	graphicsdrivers+=("mesa" "lib32-mesa")
fi
# Check for common vulkan-icd-loader to be installed:
if [ $intelcheck -eq 0 ] || [ $amdcheck -eq 0 ] || [ $aticheck -eq 0 ] || [ $nvidiacheck -eq 0 ] || [ $vmwaresvgacheck -eq 0 ]; then
	graphicsdrivers+=("vulkan-icd-loader" "lib32-vulkan-icd-loader")
fi

# Check for nvidia prime compatible 3d controllers:
echo -e "$dddcontrollers" | grep -e NVIDIA > /dev/null 2>&1
if [ $? -eq 0 ]; then
	# If available, ask if bumblebeee support is wanted:
	echo "Seems like NVidia PRIME might be available. Would you like to install bumblebee support? [Y/n]:"
	read response
	
	if [ $testingmode == "on" ]; then
	response="y"
	fi
	
	if [ "${response,,}" == "y" ] || [ "${response,,}" == "" ]; then
		bumblebeesupport="yes"
		echo "Bumblebee support will be installed!"
	elif [ "${response,,}" == "n" ]; then
		bumblebeesupport="no"
		echo "Bumblebee support will not be installed!"
	else
		echo "I did not understand that, please try again!"
	fi

	if [ $bumblebeesupport == "yes" ]; then
		graphicsdrivers+=("bumblebee" "lib32-virtualgl" "primus_vk")
	fi
fi

# Installing following graphics drivers:
graphicsinstall="graphics.list"
graphicsinstallpath="/tmp/$graphicsinstall"

# Empty file, if used before and interrupted:
echo "" > $graphicsinstallpath

if [ "${graphicsdrivers[0]}" != "" ]; then
	echo "The following graphics drivers will be installed:"
	for driver in "${!graphicsdrivers[@]}"
	do
		echo -e "${graphicsdrivers[$driver]}" >> $graphicsinstallpath
	done
	# output the results nicely:
	sed 's/^/\t/' $graphicsinstallpath
else
	echo "No graphics drivers to install!"
fi
echo

###########################################################################
# Scale and partition installation drive:
###########################################################################

echo "Setting up disk partitioning scheme..."
# First the disk is added to the sfdisk command:
instructs="instructs.sfdisk"
instructspath="/tmp/$instructs"
# The label is gpt in this installation, as it supports both EFI and legacy BIOS:
echo "label: gpt" > $instructspath
# The device picked earlier is echoed into the instructions:
echo "device: /dev/${disksavail[$choicenumber]}" >> $instructspath
# The units are sectors, and the sector size is found:
echo "unit: sectors" >> $instructspath
# Unsure whether this needs to be used:
#sectorsize=$(cat /sys/block/${disksavail[$choicenumber]}/queue/hw_sector_size)

# The start of the first partition is for the efivars, or boot sector, so it's dependant on boot type:
# Then, the type of boot is used to configure the first part of the sfdisk command:
if [ $efivarscheck -eq 2 ] 
then
	# Gives the BIOS GUID to the first partition created:
	echo "/dev/${disksavail[$choicenumber]}1 : start=2048, size=+1MiB, type=21686148-6449-6E6F-744E-656564454649" >> $instructspath
elif [ $efivarscheck -eq 0 ]
then
	# Creates an EFI partition:
	echo "/dev/${disksavail[$choicenumber]}1 : start=2048, size=+512MiB, type=C12A7328-F81F-11D2-BA4B-00A0C93EC93B" >> $instructspath
fi
# Swap is calculated:
swapsize=$(echo "$ramavail" | awk '{printf "%d", $1 * 2}') 
echo "/dev/${disksavail[$choicenumber]}2 : size=+${swapsize}GB, type=0657FD6D-A4AB-43C4-84E5-0933C84B4F4F" >> $instructspath
# Finally, the rest of the disk will be allocated for data:
echo "/dev/${disksavail[$choicenumber]}3 : type=0FC63DAF-8483-4772-8E79-3D69D8477DE4" >> $instructspath

echo "Disk partitioning scheme will be the following:"
cat $instructspath

echo "Do you want to proceed or abort? [Y/n]:"
read response

if [ $testingmode == "on" ]; then
response="y"
fi

if [ "${response,,}" == "y" ] || [ "${response,,}" == "" ]; then
	proceed="yes"
elif [ "${response,,}" == "n" ]; then
	proceed="no"
else
	echo "I did not understand that, please try again!"
fi

# Act upon response:
if [ $proceed == "yes" ]; then
	echo "Formatting disk!"
	if [ $testingmode == "on" ]; then
	sfdisk -f /dev/${disksavail[$choicenumber]} < $instructspath
	else
	sfdisk /dev/${disksavail[$choicenumber]} < $instructspath
	fi
elif [ $proceed == "no" ]; then
	echo "Aborting install..."
	rm -f $instructspath
	exit 1
else
	echo "Error! Aborting!"
	rm -f $instructspath
	exit 1
fi
echo

###########################################################################
# Make filesystems and mount them + fstab preview
###########################################################################

echo "Now creating the filesystems..."
if [ $efivarscheck -eq 2 ] 
then
	echo "For BIOS boot on GPT, no filesystem is needed on /dev/${disksavail[$choicenumber]}1!"
elif [ $efivarscheck -eq 0 ]
then
	echo "Creating FAT32 fopr EFI  on /dev/${disksavail[$choicenumber]}1..."
	mkfs.fat -F32 /dev/${disksavail[$choicenumber]}1
fi

echo "Creating swap on /dev/${disksavail[$choicenumber]}2..."
if [ $testingmode == "on" ]; then
mkswap -f /dev/${disksavail[$choicenumber]}2
else
mkswap /dev/${disksavail[$choicenumber]}2
fi

echo "Creating ext4 filesystem on /dev/${disksavail[$choicenumber]}3..."
if [ $testingmode == "on" ]; then
mkfs.ext4 -F /dev/${disksavail[$choicenumber]}3
else
mkfs.ext4 /dev/${disksavail[$choicenumber]}3
fi

echo "Mounting filesystems..."
mount /dev/${disksavail[$choicenumber]}3 /mnt
if [ $efivarscheck -eq 0 ]
then
	mkdir /mnt/efi
	mount /dev/${disksavail[$choicenumber]}1 /mnt/efi
fi
swapon /dev/${disksavail[$choicenumber]}2

echo "Fstab will be the following:"
genfstab -U /mnt
echo

###########################################################################
# Pacstrap
###########################################################################

echo "Pacstrapping base to / on ${disksavail[$choicenumber]}3 directory..."
pacstrap /mnt base
echo

###########################################################################
# Genfstab
###########################################################################

genfstab -U /mnt >> /mnt/etc/fstab

###########################################################################
# Arch-chroot and install packages from list
###########################################################################

ftphack="ftphack"
ftphackpath="$ftphack"
chrootstep="chroot-step"
chrootsteppath="$chrootstep"
packageslist="packages.list"
packageslistpath="packages/$packageslist"
aurkeys="aur.keys"
aurkeyspath="packages/$aurkeys"
configscriptspath="configscripts"
applicationspath="applications"

mkdir /mnt/root/packages
mkdir /mnt/root/info
mkdir /mnt/root/configscripts
mkdir /mnt/root/applications

cp $ftphackpath /mnt/root/$ftphackpath
cp $chrootsteppath /mnt/root/$chrootsteppath
cp $envinfopath /mnt/root/info/$envinfo
cp $tzinfopath /mnt/root/info/$tzinfo
cp $bootinfopath /mnt/root/info/$bootinfo
cp $diskinfopath /mnt/root/info/$diskinfo

if [ -f $ucodelistpath ]; then
	cp $ucodelistpath /mnt/root/packages/$ucodelist
fi
if [ -f $graphicsinstallpath ]; then
	cp $graphicsinstallpath /mnt/root/packages/$graphicsinstall
fi

cp $packageslistpath /mnt/root/$packageslistpath
cp $aurkeyspath /mnt/root/$aurkeyspath
configscripts=($(ls -w1 $configscriptspath))
for config in "${configscripts[@]}"; do
	cp $configscriptspath/$config /mnt/root/$configscriptspath/$config
	chmod 755 /mnt/root/$configscriptspath/$config
done
applications=($(ls -w1 $applicationspath))
for application in "${applications[@]}"; do
	cp $applicationspath/$application /mnt/root/$applicationspath/$application
	chmod 755 /mnt/root/$applicationspath/$application
done
chmod 755 /mnt/root/$ftphackpath
chmod 755 /mnt/root/$chrootsteppath
echo "Arch-chrooting into disk..."
arch-chroot /mnt /root/$chrootsteppath
echo "Done!"

###########################################################################
# Clean-up 
###########################################################################
umount -R /mnt
swapoff /dev/${disksavail[$choicenumber]}2
rm -f $tzinfopath
rm -f $instructspath
rm -f $graphicsinstallpath
rm -f $bootinfopath
rm -f $diskinfopath
rm -f $envinfopath
