#!/bin/bash

devmode="on"
testingmode="off"

###########################################################################
# Connect to the internet
###########################################################################

# Using nc, the connection to the internet is checked
echo "Checking for internet access..."
dns=8.8.8.8
nc -z -w 30 $dns 53 > /dev/null 2>&1
connectioncheck=$?

if [ $connectioncheck -eq 0 ] 
then
	echo "Connected to the internet!"
else
	echo "There is no connection, please remedy and run script again."
	exit 1
fi
echo

###########################################################################
# Set the system clock
###########################################################################

# Prompt, if user wants to set a timezone:
echo "Would you like to set the clock to a custom timezone? [Y/n]: "
# Check for input:
read response

if [ $testingmode == "on" ]; then
response="y"
fi

if [ "${response,,}" == "y" ] || [ "${response,,}" == "" ]; then
	timezoneselect="custom"

elif [ "${response,,}" == "n" ]; then
	timezoneselect="default"
else
	echo "I did not understand that, please try again!"
fi

# Only when properly running:
tzinfo="tz.info"
tzinfopath="/tmp/$tzinfo"
tzexit=1
while [ $tzexit -eq 1 ] && [ $timezoneselect == "custom" ]; do
	# Prompt for user specified timezone info:
	echo "Please input the timezone (format: Region/City): "
	read tzresponse

	if [ $testingmode == "on" ]; then
	tzresponse="Europe/Copenhagen"
	fi

	echo "Checking for timezone info..."
	ls /usr/share/zoneinfo/$tzresponse >/dev/null 2>&1
	timezonecheck=$?
	# If the timezone exists, then link it:
	if [ $timezonecheck -eq 0 ] && [ "$tzresponse" != "" ]; then
		echo "Timezone found!"
		tzexit=0
	# Else ask if the user wants to try again:
	else
		echo "Timezone info not found, would you like to try again? [Y/n]: "
		# Check for input:
		validresponse=1
		while [ $validresponse -eq 1 ]; do
			read response
			if [ "${response,,}" == "y" ] || [ "${response,,}" == "" ]; then
				validresponse=0
				timezoneselect="custom"
				
			elif [ "${response,,}" == "n" ]; then
				validresponse=0
				timezoneselect="default"
				tzexit=0
			else
				echo "I did not understand that, please try again!"
			fi
		done
	fi
done

# Apply changes to timezone as requested:
if [ $timezoneselect == "custom" ]; then
	echo "Timezone will be set to $tzresponse!"
elif [ $timezoneselect == "default" ]; then
	echo "Timezone will be set to default (UTC)!"
	tzresponse="UTC"
fi
echo "/usr/share/zoneinfo/$tzresponse" > $tzinfopath

# Set the system clock
echo "Synchronizing the system clock..."
timedatectl set-ntp true
timedatectl set-timezone $tzresponse
timedatectl status
echo "Done setting time!"
echo

###########################################################################
# Check the boot type:
###########################################################################

# First list the directory with efivars, and check whether they exist:
# Redirect stdout and stderr to /dev/null
echo "Checking boot type..."
ls /sys/firmware/efi/efivars > /dev/null 2>&1
efivarscheck=$?

if [ $efivarscheck -eq 2 ] 
then
	echo "The system uses BIOS boot!"
elif [ $efivarscheck -eq 0 ]
then
	echo "The system uses UEFI boot!"
fi
echo

###########################################################################
# Detect hardware: RAM
###########################################################################

echo "Detecting RAM available..."
free -h --giga
ramavail=$(free -h --giga | grep Mem | awk '{gsub("G","")} {printf "%.1f", $2}')
ramavailint=$(echo "$ramavail" | awk '{printf "%d", $1}') 
if [ $ramavailint -ne 0 ]; then
	echo "$ramavail Gigabyte RAM available!"
else
	ramavail=$(free --mega | grep Mem | awk '{printf "%.1f", $2}')
	echo "$ramavail Megabyte RAM available!"
fi
echo

###########################################################################
# Detect hardware: Storage
###########################################################################

echo "Checking disks available..."
echo "List of block devices:"
disksavail=($(lsblk | grep disk | awk '{print $1}'))
sizesavail=($(lsblk | grep disk | awk '{print $4}'))

lsblk; echo

echo "Please pick a disk to install on:"
for i in "${!disksavail[@]}"
do
	echo -e "\t$i) /dev/${disksavail[$i]} ${sizesavail[$i]}"
done
echo -e "\tq) Abort install"

# Check for input:
validresponse=1
while [ $validresponse -eq 1 ]; do
	read response

	if [ $testingmode == "on" ]; then
	response="0"
	fi
	
	# Check if response is a number, and the number index exists within the options:
	if [ $response -eq $response ] 2> /dev/null && [ "${disksavail[${response}]+y}" == "y" ]; then
		validresponse=0
		choicenumber=$response
		
	elif [ "${response,,}" == "q" ]; then
		echo "Aborting install!"
		exit 1
	else
		echo "I did not understand that, please try again!"
	fi
done
echo "You picked: $choicenumber) /dev/${disksavail[$choicenumber]} with ${sizesavail[$choicenumber]} space!"
echo

###########################################################################
# Detect hardware: Graphics
###########################################################################

echo "Checking for graphics hardware..."
# To get the graphics, two categories are searched using lspci:
if [ $testingmode == "on" ]; then 
	vgacontrollers=$(cat test/testpci | grep VGA | awk -F '"' '{print "\t" $6 " by " $4}')
	dddcontrollers=$(cat test/testpci | grep 3D | awk -F '"' '{print "\t" $6 " by " $4}')
else
	# VGA compatible cards, usually the main:
	vgacontrollers=$(lspci -mm | grep VGA | awk -F '"' '{print "\t" $6 " by " $4}')
	# 3D controllers, usually secondary in a prime setup.
	dddcontrollers=$(lspci -mm | grep 3D | awk -F '"' '{print "\t" $6 " by " $4}')
fi

# Then a check is performed to see if there are occurances in either category:
if [ "$vgacontrollers" != "" ]; then
	echo "Found VGA controllers:"
	echo -e "$vgacontrollers"
fi
if [ "$dddcontrollers" != "" ]; then
	echo "Found 3D controllers:"
	echo -e "$dddcontrollers"
fi

# Declare an array for vendors of 3d accelerated graphics:
declare -a graphicsdrivers

# Check for different corporations, to provide the drivers:
echo -e "$vgacontrollers" | grep -e NVIDIA > /dev/null 2>&1
if [ $? -eq 0 ]; then
	graphicsdrivers+=("nvidia" "nvidia-utils" "lib32-nvidia-utils")
fi

echo -e "$vgacontrollers" | grep -e Intel > /dev/null 2>&1
if [ $? -eq 0 ]; then
	graphicsdrivers+=("xf86-video-intel")
fi

echo -e "$vgacontrollers" | grep -e AMD > /dev/null 2>&1
if [ $? -eq 0 ]; then
	graphicsdrivers+=("xf86-video-amdgpu")
fi

echo -e "$vgacontrollers" | grep -e ATI > /dev/null 2>&1
if [ $? -eq 0 ]; then
	graphicsdrivers+=("xf86-video-ati")
fi

echo -e "$vgacontrollers" | grep -e ATI -e AMD -e Intel > /dev/null 2>&1
if [ $? -eq 0 ]; then
	graphicsdrivers+=("mesa" "lib32-mesa")
fi

# For now, it is assumed that a virtual machine doesn't require any other drivers for graphics:
echo -e "$vgacontrollers" | grep -e VMware > /dev/null 2>&1
if [ $? -eq 0 ]; then
	graphicsdrivers+=("")
fi

# Check for nvidia prime compatible 3d controllers:
echo -e "$dddcontrollers" | grep -e NVIDIA > /dev/null 2>&1
if [ $? -eq 0 ]; then
	# If available, ask if bumblebeee support is wanted:
	echo "Seems like NVidia PRIME might be available. Would you like to install bumblebee support? [Y/n]:"
	read response
	
	if [ $testingmode == "on" ]; then
	response="y"
	fi
	
	if [ "${response,,}" == "y" ] || [ "${response,,}" == "" ]; then
		bumblebeesupport="yes"
		echo "Bumblebee support will be installed!"
	elif [ "${response,,}" == "n" ]; then
		bumblebeesupport="no"
		echo "Bumblebee support will not be installed!"
	else
		echo "I did not understand that, please try again!"
	fi
	if [ $bumblebeesupport == "yes" ]; then
		graphicsdrivers+=("bumblebee" "lib32-virtualgl")
	fi
fi

# Installing following graphics drivers:
graphicsinstall="graphics.list"
graphicsinstallpath="/tmp/$graphicsinstall"

if [ "${graphicsdrivers[0]}" != "" ]; then
	echo "The following graphics drivers will be installed:"
	for driver in "${!graphicsdrivers[@]}"
	do
		echo -e "${graphicsdrivers[$driver]}" >> $graphicsinstallpath
	done
	# output the results nicely:
	sed 's/^/\t/' $graphicsinstallpath
else
	echo "No graphics drivers to install!"
fi
echo

###########################################################################
# Scale and partition installation drive:
###########################################################################

echo "Setting up disk partitioning scheme..."
# First the disk is added to the sfdisk command:
instructs="instructs.sfdisk"
instructspath="/tmp/$instructs"
# The label is gpt in this installation, as it supports both EFI and legacy BIOS:
echo "label: gpt" > $instructspath
# The device picked earlier is echoed into the instructions:
echo "device: /dev/${disksavail[$choicenumber]}" >> $instructspath
# The units are sectors, and the sector size is found:
echo "unit: sectors" >> $instructspath
# Unsure whether this needs to be used:
#sectorsize=$(cat /sys/block/${disksavail[$choicenumber]}/queue/hw_sector_size)

# The start of the first partition is for the efivars, or boot sector, so it's dependant on boot type:
# Then, the type of boot is used to configure the first part of the sfdisk command:
if [ $efivarscheck -eq 2 ] 
then
	# Gives the BIOS GUID to the first partition created:
	echo "/dev/${disksavail[$choicenumber]}1 : start=2048, size=+1MiB, type=21686148-6449-6E6F-744E-656564454649" >> $instructspath
elif [ $efivarscheck -eq 0 ]
then
	# Creates an EFI partition:
	echo "/dev/${disksavail[$choicenumber]}1 : start=2048, size=+1MiB, type=C12A7328-F81F-11D2-BA4B-00A0C93EC93B" >> $instructspath
fi
# Swap is calculated:
swapsize=$(echo "$ramavail" | awk '{printf "%d", $1 * 2}') 
echo "/dev/${disksavail[$choicenumber]}2 : size=+${swapsize}GB, type=0657FD6D-A4AB-43C4-84E5-0933C84B4F4F" >> $instructspath
# Finally, the rest of the disk will be allocated for data:
echo "/dev/${disksavail[$choicenumber]}3 : type=0FC63DAF-8483-4772-8E79-3D69D8477DE4" >> $instructspath

echo "Disk partitioning scheme will be the following:"
cat $instructspath

echo "Do you want to proceed or abort? [Y/n]:"
read response

if [ $testingmode == "on" ]; then
response="y"
fi

if [ "${response,,}" == "y" ] || [ "${response,,}" == "" ]; then
	proceed="yes"
elif [ "${response,,}" == "n" ]; then
	proceed="no"
else
	echo "I did not understand that, please try again!"
fi

# Act upon response:
if [ $proceed == "yes" ]; then
	echo "Formatting disk!"
	if [ $testingmode == "on" ]; then
	sfdisk -f /dev/${disksavail[$choicenumber]} < $instructspath
	else
	sfdisk /dev/${disksavail[$choicenumber]} < $instructspath
	fi
elif [ $proceed == "no" ]; then
	echo "Aborting install..."
	rm -f $instructspath
	exit 1
else
	echo "Error! Aborting!"
	rm -f $instructspath
	exit 1
fi
echo

###########################################################################
# Make filesystems and mount them + fstab preview
###########################################################################

echo "Now creating the filesystems..."
if [ $efivarscheck -eq 2 ] 
then
	echo "For BIOS boot on GPT, no filesystem is needed on /dev/${disksavail[$choicenumber]}1!"
elif [ $efivarscheck -eq 0 ]
then
	echo "Creating FAT32 fopr EFI  on /dev/${disksavail[$choicenumber]}1..."
	mkfs.fat -F32 /dev/${disksavail[$choicenumber]}1
fi

echo "Creating swap on /dev/${disksavail[$choicenumber]}2..."
if [ $testingmode == "on" ]; then
mkswap -f /dev/${disksavail[$choicenumber]}2
else
mkswap /dev/${disksavail[$choicenumber]}2
fi

echo "Creating ext4 filesystem on /dev/${disksavail[$choicenumber]}3..."
if [ $testingmode == "on" ]; then
mkfs.ext4 -F /dev/${disksavail[$choicenumber]}3
else
mkfs.ext4 /dev/${disksavail[$choicenumber]}3
fi

echo "Mounting filesystems..."
mount /dev/${disksavail[$choicenumber]}3 /mnt
if [ $efivarscheck -eq 0 ]
then
	mkdir /mnt/efi
	mount /dev/${disksavail[$choicenumber]}1 /mnt/efi
fi
swapon /dev/${disksavail[$choicenumber]}2

echo "Fstab will be the following:"
genfstab -U /mnt
echo

###########################################################################
# Pacstrap
###########################################################################

echo "Pacstrapping base to / on ${disksavail[$choicenumber]}3 directory..."
pacstrap /mnt base
echo

###########################################################################
# Genfstab
###########################################################################

genfstab -U /mnt >> /mnt/etc/fstab

###########################################################################
# Arch-chroot and install packages from list
###########################################################################

ftphack="ftphack"
ftphackpath="$ftphack"
chrootstep="chroot-step"
chrootsteppath="$chrootstep"
packageslist="packages.list"
packageslistpath="packages/$packageslist"
aurpackageslist="aur-packages.list"
aurpackageslistpath="packages/$aurpackageslist"
mkdir /mnt/root/packages
mkdir /mnt/root/info
cp $ftphackpath /mnt/root/$ftphack
cp $chrootsteppath /mnt/root/$chrootstep
cp $instructspath /mnt/root/info/$instructs
cp $tzinfopath /mnt/root/info/$tzinfo
if [ -f $graphicsinstallpath ]; then
	cp $graphicsinstallpath /mnt/root/packages/$graphicsinstall
fi
cp $packageslistpath /mnt/root/packages/$packageslist
cp $aurpackageslistpath /mnt/root/packages/$aurpackageslist
chmod 755 /mnt/root/$ftphack
chmod 755 /mnt/root/$chrootstep
echo "Arch-chrooting into disk..."
arch-chroot /mnt /root/$chrootstep
echo "Done!"

###########################################################################
# Clean-up 
###########################################################################
umount -R /mnt
swapoff /dev/${disksavail[$choicenumber]}2
rm -f $tzinfopath
rm -f $instructspath
rm -f $graphicsinstallpath
